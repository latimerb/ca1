// Replace all USER_DEFINED_SECTIONs

begintemplate template //BEGIN_USER_DEFINED_SECTION templatename END_USER_DEFINED_SECTION
public init, connect_sections, size_sections, append_sections
public mechinit, insert_mechs, set_biophys, get_root
public  pre_list, connect_pre, is_art, is_connected, gid, randi
public soma, dend, p_dend, AIS, axon
public all, basal_list, apical_list, soma_list, axon_list, dendrite_list
public x, y, z, position, myroot, Vrest
public NumSoma, NumApical, NumBasal, NumAxon

// strings
strdef myroot

// objects
objref syn, pre_list, templist, rootlist, this

// external variables
external numCellTypes, cellType

// create the sections[segments]
//BEGIN_USER_DEFINED_SECTION
NumSoma=1
NumAIS = 10
NumApical=1
NumBasal=1
NumAxon=1

create soma, dend, p_dend, AIS[numAIS], axon

//END_USER_DEFINED_SECTION
	
proc init() {
	gid = $1
	randi = $2
	
	
	//It kind of looks like as long as you add the segments to the overall list it'll work
	
	gUnf_Xsoma = 2.5e-05
	Rm = 80000 // decreased overall
	SpineScale = 1.76371308 //2
	SpineScale_leak = 1.763714578
	Cm = 2.4 // 1.8 // 2 //1
	RaAll= 150//200
	RaSoma= 150 // 146.969697
	RaDend = 150
	RaAxIs = 150//100//200
	Vpas = -72//-65//-70 // -67
	
	
	  ////////////////////////////////////////
	 //         Conductance values         //
	////////////////////////////////////////
	
	gna = 0.015
	gnap = 0.000555 // 0.000551 
	gkdr = 0.002//0.002 
	ghd = 1.5e-5//1.5e-5
	gca = 5.5e-4 
	gm = 0.00224 // 0.00222  
	gsAHP = 0.0002//0.0012
	gkap = 0.002 
	gleak = 2.5e-5 
	gleak_dend=1.57*3.0e-5
	nash=10
	Vrest = -70
	celsius = 31.0 
	
	gna12_ais_max = 3200   // Nav1.2 
	gna16_ais_max = 3200   // Nav1.6
	gkv_axon = 1000

	
	
	/////// topology ////////
	connect dend(0), soma(0)

	connect p_dend(0), soma(1)
	
	connect AIS[0](0), soma(1)
	
	for i = 0,8{ connect AIS[i+1](0) , AIS[i](1)}	
	
	connect axon(0), AIS[9] (1)
	
	
	/////// geometry ////////
	soma {L = 25 diam = 24.75 nseg = 1}		//{L = 20 diam = 20 nseg = 13}
	dend {diam= 3 L=270 nseg=8}     		// 3.5
	p_dend {diam =5 L=555 nseg=7} 
	for i=0,9 AIS[i] { L = 5 nseg = 10 diam = 1.22}
	AIS[0]	{						
		diam(	0	:	1	) = 	1.7	:	1.5
		}											
	AIS[1]	{						
		diam(	0	:	1	) = 	1.5	:	1.22
		}
	axon {L = 100 nseg = 1 diam = 1}

	access soma
	//distance()
	
	p_dend {
			insert cadyn gcabar_cadyn = gca eca = 120
			insert leak el_leak = -72  glbar_leak = gleak_dend Ra=RaDend cm = Cm // 2.5
			insert hd ghdbar_hd = ghd 
			insert na3 sh_na3=nash ar_na3=1	gbar_na3 = gna
			insert nap gbar_nap = 0  gbar_nap(1/(2*nseg)) = 0.8*gnap
			insert kdr gbar_kdr = gkdr
			insert capool taucas = 1000  fcas_capool = 0.05 
			insert sAHP gsAHPbar_sAHP = 0
			insert im gbar_im = 0 gbar_im(1/(2*nseg)) = 0.8*gm
			insert kap gkabar_kap = 0
			v=Vrest
			ena = 45
			ek = -80
			if (ismembrane("kdr") || ismembrane("kap") || ismembrane("kad")) {ek=-80}
			if (ismembrane("hd") ) {ehd_hd=-45 } // change from -30 to -50							
	}		
	soma {	
			insert cadyn gcabar_cadyn = gca  eca = 120
			insert leak el_leak= -72  glbar_leak = 1.0*gleak   Ra=RaSoma cm = Cm // 2.5
			insert hd ghdbar_hd = ghd 
			insert na3 sh_na3=nash ar_na3=1	gbar_na3 = 3*gna
			insert nap gbar_nap = gnap
			insert kdr gbar_kdr = gkdr
			insert capool taucas = 1000  fcas_capool = 0.05 //only in dend and p_dend
			insert sAHP gsAHPbar_sAHP = gsAHP
			insert im gbar_im = gm
			insert kap gkabar_kap = gkap
			v=Vrest
			ena = 45
			ek = -80
			if (ismembrane("kdr") || ismembrane("kap") || ismembrane("kad")) {ek=-80}
			if (ismembrane("hd") ) {ehd_hd=-45 } // change from -30 to -50	
	}	
	
	dend {  // need to add Spine Scale
			insert cadyn gcabar_cadyn = gca  eca = 120
			insert leak el_leak= -72  glbar_leak = gleak_dend  Ra=RaAll cm = Cm // 2.5
			insert hd ghdbar_hd = ghd
			insert na3 sh_na3=nash ar_na3=1	gbar_na3 = gna
			insert nap gbar_nap = 0 gbar_nap(1/(2*nseg)) = 1.0*gnap
			insert kdr gbar_kdr = gkdr
			insert capool taucas = 1000  fcas_capool = 0.05 
			insert sAHP gsAHPbar_sAHP = 0
			insert im gbar_im = 0 gbar_im(1/(2*nseg)) = 1.0*gm
			insert kap gkabar_kap = gkap
			v=Vrest
			ena = 45
			ek = -80
			if (ismembrane("kdr") || ismembrane("kap") || ismembrane("kad")) {ek=-80}
			if (ismembrane("hd") ) {ehd_hd=-45 } // change from -30 to -50	
	}
	
	for i=0,9 AIS[i] {
			insert pas
			Ra = 150
			cm = 0.5
			g_pas = 1/30000
			e_pas = -70
			insert na12  gbar_na12=0
			insert na16  gbar_na16=0
			insert kv    gbar_kv = 0
			}
					
	AIS[0]. gbar_na12= gna12_ais_max      *	0.96	*	1                  								
	AIS[1]. gbar_na12= gna12_ais_max  		*	0.9	*	1                    
	AIS[2]. gbar_na12= gna12_ais_max  		*	0.75	*	1                  
	AIS[3]. gbar_na12= gna12_ais_max  		*	0.55	*	0.95               
	AIS[4]. gbar_na12= gna12_ais_max  		*	0.366985879	*	0.880142857  
	AIS[5]. gbar_na12= gna12_ais_max  		*	0.2	*	0.75                 
	AIS[6]. gbar_na12= gna12_ais_max  		*	0.100330761	*	0.647857143  
	AIS[7]. gbar_na12= gna12_ais_max  		*	0.011532125	*	0.520285714  
	AIS[8]. gbar_na12= gna12_ais_max  		*	0	*	0.428571429            
	AIS[9]. gbar_na12= gna12_ais_max  		*	0	*	0.342857143 
	
	AIS[0]. gbar_na16 = gna16_ais_max	*	0.04	*	1   
	AIS[1]. gbar_na16 = gna16_ais_max	*	0.1	*	1   
	AIS[2]. gbar_na16 = gna16_ais_max	*	0.25	*	1   
	AIS[3]. gbar_na16 = gna16_ais_max	*	0.45	*	0.95   
	AIS[4]. gbar_na16 = gna16_ais_max	*	0.633014121	*	0.880142857   
	AIS[5]. gbar_na16 = gna16_ais_max	*	0.8	*	0.75   
	AIS[6]. gbar_na16 = gna16_ais_max	*	0.899669239	*	0.647857143   
	AIS[7]. gbar_na16 = gna16_ais_max	*	0.988467875	*	0.520285714   
	AIS[8]. gbar_na16 = gna16_ais_max	*	1	*	0.428571429   
	AIS[9]. gbar_na16 = gna16_ais_max	*	1	*	0.342857143  
			
	
	AIS[0]. gbar_kv = gkv_axon	*	0.2 
	AIS[1]. gbar_kv = gkv_axon	*	0.3 
	AIS[2]. gbar_kv = gkv_axon	*	0.4 
	AIS[3]. gbar_kv = gkv_axon	*	0.5 
	AIS[4]. gbar_kv = gkv_axon	*	0.6 
	AIS[5]. gbar_kv = gkv_axon	*	0.7 
	AIS[6]. gbar_kv = gkv_axon	*	0.8 
	AIS[7]. gbar_kv = gkv_axon	*	0.9
	AIS[8]. gbar_kv = gkv_axon	*	1
	AIS[9]. gbar_kv = gkv_axon	*	1

	
	axon{
			insert pas
			Ra = 150
			cm = 1
			g_pas = 1/30000
			e_pas = -70
			insert na12  gbar_na12=0
			insert na16  gbar_na16=300
			insert kv    gbar_kv= 1500
	}
	
	
	
	
	// morphology
	connect_sections()	// local fcn: connect soma, dendrites, axon initial segment
	size_sections()		// local fcn: set the size dimensions of each section
	define_shape()		// builtin fcn: fill in 3d info for sections defined by only L and diam, translate 3d points for consistency with their connections 
  	append_sections()	// local fcn: append all sections to the section list
	set_nseg()			// local fcn: set the number of segments in each section
	get_root()			// local fcn: perform morphology checks

	// electrophysiology
	mechinit()			// local fcn: set values for max conductances and reversal potentials of ion channels and other ephys parameters that are subject to fitting
	insert_mechs()		// local fcn: insert ion channels and actually set values determined in the mechinit fcn
	set_chanparams()	// local fcn: after all channels have been inserted, then their other parameters can be set	

	// synapses
	pre_list = new List() // define a list for the presynaptic connections
	define_synapses($3)	// local fcn: define all possible synaptic connections received by this cell
		
}

proc connect_sections() { local i

	//Connect the dends to somas, etc
	//Example: 
	// connect dend[0](0), soma(1)
	// for i=0,3 {
	// 	 connect dend[i+1](0), dend[i](1)
	// }
	//BEGIN_USER_DEFINED_SECTION
	
	
	
	//END_USER_DEFINED_SECTION
	
}

objref all, basal_list, apical_list, dendrite_list, soma_list, axon_list

proc append_sections() { local i
	objref all, basal_list, apical_list, dendrite_list, soma_list, axon_list

	all = new SectionList()
	basal_list = new SectionList()
	apical_list = new SectionList()
	soma_list = new SectionList()
	axon_list = new SectionList()
	dendrite_list = new SectionList()
	
	//Add sections to the list accessed by mother program
	//Example:
	// soma all.append()
	// soma soma_list.append()
	// for i=0,15 {
	//	 dend[i] all.append()
	//	 dend[i] dendrite_list.append()
	// }
	//BEGIN_USER_DEFINED_SECTION
	
	soma all.append()
	soma soma_list.append()
	
	dend all.append()
	dend dendrite_list.append()
	
	p_dend all.append()
	p_dend dendrite_list.append()
	
	for i=0,numAIS {
		AIS[i] all.append()
		AIS[i] axon_list.append()
	}
	
	axon all.append()
	axon axon_list.append()
	
	
	
	//END_USER_DEFINED_SECTION
}

external lambda_f
proc set_nseg() {
  	forsec all { nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1  }
}

proc mechinit() {
	// Temperature of simulation
	celsius = 34.0
	
	//Initialize properties of channels, vrest
	//Example:
	// CmSoma= 1.4
	// CmDend = 1.4
	// ca_outside = 2
	// ca_inside = 5.e-6 // 50.e-6
	// catau = 10
	// gNav     = 0.15
	//BEGIN_USER_DEFINED_SECTION
	
	
	
	//END_USER_DEFINED_SECTION
	
}

proc insert_mechs() {
	//*** insert the channels into the cells
	//Example:
	// forsec all {		
	//	insert ch_KvA
	//	gmax_ch_KvA = gKvA
	// }
	// soma {
	//  insert ch_Nav	
	//  gmax_ch_Nav = gNav
	// }
	// forsec dendrite_list {
	// }
	//BEGIN_USER_DEFINED_SECTION
	
	
	
	//END_USER_DEFINED_SECTION

}


proc set_chanparams() {
	//*** insert the channels into the cells
	//Example:
	// forsec all {
	//  ena = enaval
	//  ek = ekval
	//  eca = ecaval
	//  e_ch_leak = eleakval
	//  cao_iconc_Ca = ca_outside
	// }
	//BEGIN_USER_DEFINED_SECTION
	
	
	
	//END_USER_DEFINED_SECTION

}

proc connect_pre() {  // $o1 target point process, $o2 returned NetCon
	soma $o2 = new NetCon (&v(1), $o1)
			$o2.threshold = -10

}

func is_art()  { //Artificial Cell?
	return 0 
}

proc position(){ local i
	forall {
		for i = 0, n3d()-1 {
			pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
		}
	}
	x = $1  y = $2  z = $3	
}

proc get_root() {local i localobj sref
	rootlist = new SectionList()
	rootlist.allroots()
	i=0
	forsec all {
		sref = new SectionRef()
		if (sref.has_parent==0) {
			myroot = secname()
			i=i+1
		}
		for(x,0) {
			if (diam(x) <=0.01) print "WARNING: tiny diameter of ",  diam(x), " um at ", secname(), ", point ", x, "!"
			if (diam3d(x) <=0.01) print "WARNING: tiny 3d diameter of ", diam3d(x), " um at ", secname(), ", point ", x, "!"
		}
		if (L <=0.001) print "WARNING: tiny length of ", L, " um at ", secname(), "!"
	}
	if (i>1) {
		print "WARNING: cell ", gid, " has ", i, " root sections!"
	}
}

strdef myStr

objref newSecRef, syn
proc define_synapses() {
	ind = $1
	i = 0

	access soma[0]
	{distance()}

	for celltype = 0, numCellTypes-1 {
		templist = new List ()
		for r=0, cellType[ind].SynList[celltype].count()-1 {
			execute(cellType[ind].SynList[celltype].object(r).NewSynStr, this) // sets newSecRef
						
			forsec newSecRef {		
				for (x,0) {
					execute(cellType[ind].SynList[celltype].object(r).CondStr, this)
					 if (y==1) {
						execute(cellType[ind].SynList[celltype].object(r).SynStr, this)
						if (cellType[ind].SynList[celltype].object(r).GABAabFlag==0) {
							syn.tau1 = cellType[ind].SynList[celltype].object(r).tau1
							syn.tau2 = cellType[ind].SynList[celltype].object(r).tau2
							syn.e = cellType[ind].SynList[celltype].object(r).efirst
							if (strcmp(cellType[ind].SynList[celltype].object(r).SynType,"MyExp2Sidnw")==0) {
								execute(cellType[ind].SynList[celltype].object(r).Scaling, this)
							}
						} else {
							syn.tau1a = cellType[ind].SynList[celltype].object(r).tau1a
							syn.tau2a = cellType[ind].SynList[celltype].object(r).tau2a
							syn.ea = cellType[ind].SynList[celltype].object(r).ea
							syn.tau1b = cellType[ind].SynList[celltype].object(r).tau1b
							syn.tau2b = cellType[ind].SynList[celltype].object(r).tau2b
							syn.eb = cellType[ind].SynList[celltype].object(r).eb
						}
						syn.sid = i
						templist.append(syn)
						i = i + 1
					}
				}
			}
		}
		pre_list.append(templist)
		findme = 1
	}
}
endtemplate template //BEGIN_USER_DEFINED_SECTION templatename END_USER_DEFINED_SECTION